name: Publish Release

permissions:
  contents: write

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Optional semver (e.g., 1.2.3 or v1.2.3). If omitted, the patch of the latest tag will be bumped."
        required: false
        type: string

jobs:
  tag:
    name: Determine and create tag
    runs-on: ubuntu-latest
    outputs:
      tag_name: ${{ steps.vars.outputs.new_tag }}
    steps:
      - name: Checkout repository (with tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Configure Git user
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "1319595+github-actions[bot]@users.noreply.github.com"

      - name: Determine new tag
        id: vars
        shell: bash
        run: |
          set -euo pipefail

          INPUT_VERSION="${{ github.event.inputs.version }}"

          semver_regex='^v?[0-9]+\.[0-9]+\.[0-9]+$'

          if [[ -n "$INPUT_VERSION" ]]; then
            if [[ ! "$INPUT_VERSION" =~ $semver_regex ]]; then
              echo "Provided version '$INPUT_VERSION' is not a valid semver (expected 1.2.3 or v1.2.3)." >&2
              exit 1
            fi
            # Normalize to 'v' prefix
            if [[ "$INPUT_VERSION" == v* ]]; then
              NEW_TAG="$INPUT_VERSION"
            else
              NEW_TAG="v$INPUT_VERSION"
            fi
          else
            # Get latest tag (if any)
            LATEST_TAG="$(git describe --tags --abbrev=0 2>/dev/null || true)"

            if [[ -z "$LATEST_TAG" ]]; then
              # Start from 0.0.1 when no tags exist
              NEW_TAG="v0.0.1"
            else
              # Preserve optional 'v' prefix
              PREFIX=""
              CORE="$LATEST_TAG"
              if [[ "$LATEST_TAG" == v* ]]; then
                PREFIX="v"
                CORE="${LATEST_TAG#v}"
              fi

              IFS='.' read -r MAJOR MINOR PATCH <<< "$CORE"

              # Basic validation to ensure we parsed numbers
              if [[ -z "$MAJOR" || -z "$MINOR" || -z "$PATCH" ]]; then
                echo "Latest tag '$LATEST_TAG' is not in expected semver format." >&2
                exit 1
              fi

              PATCH=$((PATCH + 1))
              NEW_TAG="${PREFIX}${MAJOR}.${MINOR}.${PATCH}"
            fi
          fi

          echo "Computed new tag: $NEW_TAG"
          echo "new_tag=$NEW_TAG" >> "$GITHUB_OUTPUT"

      - name: Create annotated tag
        run: |
          TAG="${{ steps.vars.outputs.new_tag }}"
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag '$TAG' already exists. Nothing to do." >&2
            exit 1
          fi
          git tag -a "$TAG" -m "Release $TAG"

      - name: Push tag
        run: |
          TAG="${{ steps.vars.outputs.new_tag }}"
          git push origin "$TAG"

  build:
    name: Build binaries (${{ matrix.goos }}-${{ matrix.goarch }})
    needs: tag
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        goos: [linux, darwin, windows]
        goarch: [amd64, arm64]
        exclude:
          # Windows/arm64 cross-compile is supported, but exclude if not desired
          # - goos: windows
          #   goarch: arm64
          []
    steps:
      - name: Checkout tagged ref
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ needs.tag.outputs.tag_name }}

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod

      - name: Build
        run: |
          set -euo pipefail
          BIN_NAME=syncai
          OUT_DIR=dist
          mkdir -p "$OUT_DIR"
          EXT=""
          if [ "${{ matrix.goos }}" = "windows" ]; then EXT=".exe"; fi
          CGO_ENABLED=0 GOOS=${{ matrix.goos }} GOARCH=${{ matrix.goarch }} go build -ldflags "-s -w" -o "$OUT_DIR/${BIN_NAME}_${{ matrix.goos }}_${{ matrix.goarch }}$EXT" ./cmd

      - name: Archive
        run: |
          set -euo pipefail
          OUT_DIR=dist
          FILE_BASE=syncai_${{ matrix.goos }}_${{ matrix.goarch }}
          # Copy default config into dist so it can be included into archives
          cp syncai.json "$OUT_DIR/"
          if [ "${{ matrix.goos }}" = "windows" ]; then
            # Include both the binary and the config file
            zip -j "$OUT_DIR/${FILE_BASE}.zip" "$OUT_DIR/${FILE_BASE}.exe" "$OUT_DIR/syncai.json"
            echo "ARCHIVE_PATH=$OUT_DIR/${FILE_BASE}.zip" >> $GITHUB_ENV
          else
            # Include both the binary and the config file
            tar -C "$OUT_DIR" -czf "$OUT_DIR/${FILE_BASE}.tar.gz" "${FILE_BASE}" "syncai.json"
            echo "ARCHIVE_PATH=$OUT_DIR/${FILE_BASE}.tar.gz" >> $GITHUB_ENV
          fi

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: syncai_${{ matrix.goos }}_${{ matrix.goarch }}
          path: ${{ env.ARCHIVE_PATH }}
          if-no-files-found: error

  release:
    name: Create GitHub Release and upload assets
    needs: [tag, build]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout tagged ref
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ needs.tag.outputs.tag_name }}

      - name: Set node
        uses: actions/setup-node@v4
        with:
          registry-url: https://registry.npmjs.org/
          node-version: lts/*

      - name: Generate release notes with changelogithub
        run: npx changelogithub # or changelogithub@0.12 to ensure a stable result
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: syncai_*
          merge-multiple: true
          path: dist

      - name: Upload assets to GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.tag.outputs.tag_name }}
          files: |
            dist/*.tar.gz
            dist/*.zip
            syncai.json
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}